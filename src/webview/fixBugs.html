<!DOCTYPE html>
<html>
<head>
  <style>
    body { padding: 0; margin: 0; font-family: var(--vscode-font-family); display: flex; height: 100vh; }
    .left { width: 40%; padding: 20px; overflow-y: auto; border-right: 1px solid var(--vscode-panel-border); }
    .right { width: 60%; padding: 20px; display: flex; flex-direction: column; }
    input { width: 100%; padding: 8px; margin-bottom: 10px; }
    .filter-group { margin-bottom: 10px; }
    .filter-group h4 { margin: 0 0 3px 0; }
    .checkbox { margin: 1px 0; display: flex; align-items: center; }
    .checkbox input { width: auto; margin-right: 5px; }
    textarea { width: 100%; flex: 1; font-family: monospace; margin-bottom: 10px; }
    button { padding: 10px 20px; }
  </style>
</head>
<body>
  <div class="left">
    <div id="totalCount" style="font-weight: bold; margin-bottom: 10px;">Total: <span id="issueCount">0</span> issues</div>
    <details class="filter-group">
      <summary>Type</summary>
      <div id="typeFilters"></div>
    </details>
    <details class="filter-group">
      <summary>Severity</summary>
      <div id="severityFilters"></div>
    </details>
    <details class="filter-group">
      <summary>Rule</summary>
      <div id="ruleFilters"></div>
    </details>
    <details class="filter-group">
      <summary>Directory</summary>
      <div id="directoryFilters"></div>
    </details>
    <details class="filter-group">
      <summary>File</summary>
      <div id="fileFilters"></div>
    </details>
  </div>
  <div class="right">
    <textarea id="prompt"></textarea>
    <input type="text" id="dir" />
    <button id="btn" onclick="fix()" disabled>Fix</button>
  </div>
  <script>
    const vscode = acquireVsCodeApi();
    let issues = [];
    let currentFile = '';
    let filteredIssues = [];
    
    function initializeUI(issuesData, workspaceFolder) {
      issues = issuesData;
      filteredIssues = issues;
      
      // Set workspace folder
      document.getElementById('dir').value = workspaceFolder;
      
      // Initial filter
      filter();
    }
    
    function populateFilters(containerId, values) {
      const container = document.getElementById(containerId);
      const checkedValues = Array.from(document.querySelectorAll(`#${containerId} input[type="checkbox"]:checked`)).map(cb => cb.value);

      // Sort values by count (descending)
      const sortedValues = [...values].sort((a, b) => {
        const countA = getCountForValue(containerId, a);
        const countB = getCountForValue(containerId, b);
        return countB - countA; // highest count first
      });

      container.innerHTML = sortedValues.map(value => {
        const count = getCountForValue(containerId, value);
        const checked = checkedValues.includes(value) ? 'checked' : '';
        return count > 0
          ? `<div class="checkbox">
              <input type="checkbox" value="${value}" onchange="filter()" ${checked}> 
              ${value} (${count})
            </div>`
          : '';

      }).join('');
    }
    
    const filterMappings = {
      'typeFilters': i => i.type,
      'severityFilters': i => i.severity,
      'ruleFilters': i => i.rule,
      'directoryFilters': i => i.component.split(':')[1].split('/').slice(0, -1).join('/'),
      'fileFilters': i => i.component
    };
    
    function getCountForValue(containerId, value) {
      const filteredIssues = getFilteredIssuesExcluding(containerId);
      return filteredIssues.filter(i => filterMappings[containerId](i) === value).length;
    }
    
    function getCheckedValues(containerId) {
      return Array.from(document.querySelectorAll(`#${containerId} input[type="checkbox"]:checked`)).map(cb => cb.value);
    }
    
    function getFilteredIssuesExcluding(excludeContainerId) {
      const filters = {
        'typeFilters': excludeContainerId !== 'typeFilters' ? getCheckedValues('typeFilters') : [],
        'severityFilters': excludeContainerId !== 'severityFilters' ? getCheckedValues('severityFilters') : [],
        'ruleFilters': excludeContainerId !== 'ruleFilters' ? getCheckedValues('ruleFilters') : [],
        'directoryFilters': excludeContainerId !== 'directoryFilters' ? getCheckedValues('directoryFilters') : [],
        'fileFilters': excludeContainerId !== 'fileFilters' ? getCheckedValues('fileFilters') : []
      };
      
      return issues.filter(issue => {
        if (filters.typeFilters.length > 0 && !filters.typeFilters.includes(issue.type)) return false;
        if (filters.severityFilters.length > 0 && !filters.severityFilters.includes(issue.severity)) return false;
        if (filters.ruleFilters.length > 0 && !filters.ruleFilters.includes(issue.rule)) return false;
        if (filters.directoryFilters.length > 0 && !filters.directoryFilters.some(dir => issue.component.includes(dir))) return false;
        if (filters.fileFilters.length > 0 && !filters.fileFilters.includes(issue.component)) return false;
        return true;
      });
    }
    
    function filter() {
      // Initialize filters if not already done
      if (document.getElementById('typeFilters').children.length === 0) {
        updateAllFilterCounts();
      }
      
      filteredIssues = getFilteredIssuesExcluding('');
      updateAllFilterCounts();
      
      const groupedByFile = filteredIssues.reduce((acc, issue) => {
        if (!acc[issue.component]) acc[issue.component] = [];
        acc[issue.component].push(issue);
        return acc;
      }, {});
      
      const text = Object.entries(groupedByFile).map(([file, fileIssues]) => {
        const fileText = `File: ${file} (${fileIssues.length} issues)\n`;
        const issuesText = fileIssues.map((issue, idx) => 
          `  Issue ${idx + 1}:\n  Message: ${issue.message}\n  Severity: ${issue.severity}\n${issue.line ? `  Line: ${issue.line}\n` : ''}  Rule: ${issue.rule}\n\n`
        ).join('');
        return fileText + issuesText;
      }).join('') + 'Fix these SAST issues';
      
      document.getElementById('prompt').value = text;
      document.getElementById('btn').disabled = filteredIssues.length === 0;
      document.getElementById('issueCount').textContent = filteredIssues.length;
      
      if (filteredIssues.length > 0) {
        currentFile = filteredIssues[0].component;
      }
    }
    
    function updateAllFilterCounts() {
      const filterConfigs = {
        'typeFilters': issues.map(i => i.type),
        'severityFilters': issues.map(i => i.severity),
        'ruleFilters': issues.map(i => i.rule),
        'directoryFilters': issues.map(i => i.component.split(':')[1].split('/').slice(0, -1).join('/')),
        'fileFilters': issues.map(i => i.component)
      };
      
      Object.entries(filterConfigs).forEach(([containerId, values]) => {
        populateFilters(containerId, [...new Set(values)]);
      });
    }
    
    function fix() {
      if (filteredIssues.length === 0) return;
      const prompt = document.getElementById('prompt').value;
      const filePath = currentFile.includes(':') ? currentFile.split(':').slice(1).join(':') : currentFile;
      const dir = document.getElementById('dir').value;
      vscode.postMessage({ command: 'fix', prompt: prompt, file: filePath, dir: dir });
    }
    
    // Listen for messages from the extension
    window.addEventListener('message', event => {
      const message = event.data;
      if (message.command === 'initialize') {
        initializeUI(message.issues, message.workspaceFolder);
      }
    });
  </script>
</body>
</html>
